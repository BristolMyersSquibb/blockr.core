---
title: "2. Create a block"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{2. Create a block}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(blockr.core)
```

## Creating blocks

**Note:** If you are not already familiar with [Shiny modules](https://shiny.posit.co/r/articles/improve/modules/), it is recommended you do so before continuing with this section.

Blockr is built on top of Shiny. At it's heart, a block is just a specialised Shiny module that returns two additional values:

- **An expression** (called "expr"), a reactive expression defining a blocks computation. This allows R code to be exported and  data analyses to be recreated, outside of blockr and a reactive context.
- **A state object** (called "state"), a list of reactive values tracking user inputs. This allows blocks to separate user-defined state from inputs specified by blocks.

Blocks consists of three elements:

1. A **UI function** to define the user interface. 
2. A **Server function** to handle reactive logic that returns an expression and state object.
3. A **Constructor function** wraps the UI and server to intialize the block state.

Now, let's go through each element, building up a block template as we go.

### UI function

A UI function in blockr is the same as a UI function in a Shiny module.
This means that:

- The UI function signature is expected to contain a single `id` argument, which can be used with `shiny::NS()` to construct namespaced IDs.
- A call to appropriate shiny UI functions is expected that return `shiny.tag` or `shiny.tag.list` objects, typically via the use of `shiny::tagList()` in the UI to list separate UI elements.

Let's start to build our block template:

```{r, eval = FALSE}
ui <- function(id) {
  tagList(
    # Wrap widgets in `tagList()`
    textInput(
      NS(id, "my_input") # Use `shiny::NS()` to construct namespaces
    )
  )
}

```

### Server function

As inputs, a server function takes an id and any additional inputs from other blocks (e.g., data).

A server function shold return as ouput a `moduleServer()` call, defining:

- **expr**: A quoted reactive expression representing the blockâ€™s computation.
- **state**: A list of reactive values tracking user selections.

```{r eval = FALSE}
function(id, ...) {
  moduleServer(id, function(input, output, session) {
    # Reactive logic goes here

    # Return a list with "expr" and "state"
    list(
      expr = reactive(quote(identity(...))),
      state = list()
    )
  })
}
```


### Constructor function

The constructor function wraps the UI and server functions and initializes the block.

It should expose as arguments anything the user might set via the UI to control the block state.
In other words, any inputs in the UI function, should have a corresponding argument in the constructor function.
On the other hand, inputs from other blocks should not be exposed as arguments, as these are dynamically provided in the server function.

The return value should be a call to `new_block()` (or if applicable a call to the more specific *virtual* constructors `new_data_block()`, `new_transform_block()`, etc.).

We can finish out block template:

```{r eval = FALSE}
example_constructor_function(ui_state = character())
{
  ui <- function(id) {
    tagList(textInput(NS(id, "ui_state")))
  }

  server <- function() {
    # Reactive logic goes here

    # Return "expr" and "state"
    list(
      expr = reactive(quote(identity(...))),
      state = list(reactive(ui_state()))
    )
  }

  # Return call to `new_block()`
  new_block()
}

```

### Example

Putting this all together, we can create a ...